<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <title>Title</title>
  <link rel="SHORTCUT ICON" href="/favicon.ico" />
  <style type="text/css" media="screen">
    /* from Eric Meyer: v1.0 | 20080212 */
    html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, font, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td{background:transparent;border:0;font-size:100%;font-weight:inherit;margin:0;outline:0;padding:0;text-decoration:none;vertical-align:baseline}
    body{line-height:1}
    ol, ul{list-style:none}
    blockquote, q{quotes:none}
    blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}
    /* remember to define focus styles! */
    :focus{outline:0}
    /* remember to highlight inserts somehow! */
    ins{text-decoration:none}
    del{text-decoration:line-through}
    table{border-collapse:collapse;border-spacing:0}
    /* end of Eric Meyer's CSS Reset */

    body, input, select, textarea{font-family:'helvetica neue',helvetica,arial,sans-serif;font-size:16px;line-height:20px}
    
    p{margin:0 auto;padding:0 20px 20px;max-width:960px;}
    
    .aside{display:inline;}
    
    /* For users with JS disabled */
    .aside:before{content:'— '}
    .aside:after{content:' —'}
    .aside.parens:before, .aside .aside:before{content:' ('}
    .aside.parens:after, .aside .aside:after{content:') '}
    
    .aside.top{font-weight:bold}
    .aside.top span{font-weight:normal;}
    
    /* The 'modified' class gets added in by JS. */
    .aside.modified{border-radius:6px;display:inline-block;float:right;margin:10px;padding:10px;max-width:50%;}
    .aside .aside.modified{margin:0;}
    .aside.modified:before{content:''}
    .aside.modified:after{content:''}
    
    .connector{display:inline-block;margin:10px 0 0 .125em;position:absolute;}

    .connector_spacer{display:inline-block;width:.25em;}
    #canvas_container{position:absolute;top:0;z-index:-1}
    #holder{margin-top:200px;}
  </style>

</head>
<body>
<div id="canvas_container"></div>
<div id="holder" style="background:pink"></div>
  <p>The general idea: A block of text has inline callouts <span class="aside">callouts are asides and parentheticals that build on the primary text <span class="aside">or the secondary or tertiary<span class="aside">or whatever</span> text</span></span> that can be safely excerpted and referenced. A static anchor within the text displays the originating branch point. A line connects the callout to the anchor.</p>
  <p>Asides have a certain color <span class="aside parens">randomly assigned from a predefined set</span>, and child asides within a parent have the same hue and saturation as the parent, but are lighter<span class="aside">yay, <a href="http://mothereffinghsl.com">HSL</a>!</span>.</p>
  
  <hr />
  
  
  <script src="lib/jquerymin.js" type="text/javascript" charset="utf-8"></script>
  <script src="lib/colormin.js" type="text/javascript" charset="utf-8"></script>
<script src="lib/raphaelmin.js" type="text/javascript" charset="utf-8"></script>

<script type="text/javascript" charset="utf-8">
jQuery.extend(jQuery.fn, {
  hasParent: function(p) {
    return this.filter(function(){
      return $(p).find(this).length;
    });
  },
  hasAncestor: function(a) {
    return !!$(this).closest(a).length;
  }
});
var colors = ["rgb(239, 121, 1)", "rgb(213, 68, 33)", "rgb(152, 191, 13)", "rgb(1, 176, 236)", "rgb(116, 73, 241)", "rgb(177, 71, 163)", "rgb(246, 180, 2)", "rgb(141, 141, 141)"]
$(function(){
  var i = 0;
  $('.aside').addClass('modified').each(function(i){
    $(this).attr('id', 'target'+i).css('background',colors[i % colors.length]).before('<span class="connector" id="anchor'+i+'"></span>');
    if($(this).hasAncestor('.aside')){$(this).addClass('merp')}else{$(this).addClass('yawp')}
    // if this aside has no parents with the class "aside", then it's a top-level aside.
    // we need to define the top-level asides, then paint them according to the color list.
    i++;
  })
  $('.aside .aside').css({'background':'rgba(255,255,255,0.4)'})
  var paper = new Raphael(document.getElementById('canvas_container'), 500, 500);
  var circle = paper.circle(100, 100, 80);
  var c = paper.path("M10 10 L90 90");
  var b = paper.path("M50 30 Q130 40 130 200 Q400 20 100 130").attr({});
  var b = paper.path("M120 130 C160 40 130 240 200 130");

  // ROUGH EDGE: The above lines are working. You need to now figure out WHERE the boxes are, and DRAW IN the lines leading to them

//  var r = new Raphael(document.getElementById('holder'), 400, 400);
  //curve(20, 30, 40, 50, 60, 70, 80, 90, "#c0c");
//  curve(70, 100, 110, 100, 130, 200, 170, 200, "hsb(0, .75, .75)");
//  curve(90, 100, 120, 130, 100, 400, 570, 200, "hsb(0, .75, .75)");
  
  for(var i = 0; i < $('.aside').length; i++){
      console.log(i)
  
  var a = $("#anchor"+i)
  var t = $("#target"+i)
  
  var anchorLeft = a.position().left;
  console.log("anchorLeft = " + anchorLeft);
  var targetLeft = t.position().left;
  console.log("targetLeft = " + targetLeft);
  var diffLeft = targetLeft - anchorLeft;
  console.log(diffLeft);
  var anchorTop = a.position().top;
  console.log("anchorTop = " + anchorTop);
  var targetTop = t.position().top;
  console.log("targetTop = " + targetTop);
  var diffTop = targetTop - anchorTop;
  var diffTopWithPadding = parseInt(diffTop, 10)+100;
  console.log(diffTop);
  a.height(diffTopWithPadding).after("<span class='connector_spacer'></span>");
  var diffTopWithPadding = parseInt(diffTop, 10)+10;
  var arrowEndV = diffTopWithPadding;
  var diffLeftWithPadding = parseInt(diffLeft, 10);
  var arrowV = diffTopWithPadding;
  if(diffLeft > 0){
    a.width(diffLeftWithPadding);
    var arrowEndH = diffLeftWithPadding;
    var arrowH = diffLeftWithPadding;
  } else {
    var arrowH = 0;
  }
/*  if(diffTop > 0){
    a.height(diffTop).css('margin', '12px 0 0').after("<span class='connector_spacer'></span>");
  }
  */
  var paper = new Raphael(document.getElementById('anchor'+i), 200, 20);
  console.log("attn: "+diffLeftWithPadding);
  var c = paper.path("M 2 2 C 4 4 20 20 "+arrowEndH+" "+arrowEndV).attr({'stroke-width':'1.2px', 'stroke-linecap':'round', 'arrow-end':'block-wide-long'});
}
  
  
});

function curve(x, y, ax, ay, bx, by, zx, zy, color) {
//    var path = [["M", x, y], ["C", ax, ay, bx, by, zx, zy]];
//    curve = r.path(path).attr({stroke: color, "stroke-width": 3, "stroke-linecap": "round"});
    r.circle(10, 10, 8)
}
</script>
</body>
</html>